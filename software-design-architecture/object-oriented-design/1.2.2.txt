Language is an interesting idea.
语言是一个有趣的概念。

 The word language is used to describe a system that we use to communicate our thoughts and ideas with each other.
语言这个词是用来描述我们用来相互交流思想和想法的系统。

 There are different ways in which the system can be used.
这个系统有不同的使用方法。

 We can communicate through writing, reading, speaking, drawing pictures or even making gestures with our body.
我们可以通过写作、阅读、说话、画画甚至用身体做手势来交流。

 Language has allowed us to create incredible things like the pyramids and solve complex problems that help us understand our world.
语言使我们能够创造出像金字塔这样不可思议的东西，并解决复杂的问题来帮助我们了解我们的世界。

 It even helps us communicate the most basic things to other people.
它甚至帮助我们与他人沟通最基本的事情。

 But, as with many things in our lives, we have to adapt language to meet our needs.
但是，就像我们生活中的许多事情一样，我们必须调整语言来满足我们的需求。

 Language has evolved over the many years of human existence.
语言是在人类存在的许多年里进化而来的。

 Think about how language has changed with the integration of modern technology and the rise of Internet culture.
想想语言是如何随着现代技术的融合和互联网文化的兴起而改变的。

 Programming languages evolved in a similar fashion as traditional languages.
编程语言的演变与传统语言类似。

 Each new programming language was developed to provide solutions to problems that previous languages were unable to adequately address.
开发每一种新的编程语言都是为了解决以前的语言无法充分解决的问题。

 Over the years, ideas used in computer languages have caused a shift in programming paradigms.
多年来，计算机语言中使用的思想已经引起了编程范式的转变。

 We needed to change the way in which programs were written in order to address the latest problems more effectively.
我们需要改变程序的编写方式，以便更有效地解决最新的问题。

 If you're a veteran of the software industry, you may remember languages such as COBOL and Fortran.
如果您是软件行业的老手，您可能记得诸如COBOL和Fortran之类的语言。

 If you're new to the software scene, these are languages you may have heard of but have never actually used.
如果您是软件领域的新手，那么您可能听说过这些语言，但从未真正使用过。

 So, what programming paradigm do these two languages follow?
那么，这两种语言遵循什么编程范式呢?

 Have you met Ted?
你见过泰德吗?

 Ted is a software developer making his way through the different ages of programming languages and programming paradigms.
Ted是一位软件开发人员，他经历了编程语言和编程范例的不同时代。

 We'll be following Ted from the early years of computers, when computers were designed to simply process batches of input into output.
我们将从计算机的早期开始跟踪Ted，那时计算机被设计成简单地将批量输入处理成输出。

 Ted will finish his journey in our modern day society, where computers help us with complex tasks.
泰德将在我们现代社会完成他的旅程，在那里计算机帮助我们完成复杂的任务。

 Ted begins his career in the 1960s.
泰德在20世纪60年代开始了他的职业生涯。

 He has just been hired by a bank to develop their very first program that will be used to keep track of account balances.
他刚刚受聘于一家银行，开发他们的第一个用于跟踪账户余额的程序。

 In these days, the two most popular programming languages were COBOL and Fortran.
在这些日子里，最流行的两种编程语言是COBOL和Fortran。

 They followed an imperative paradigm which broke up large programs into smaller programs called subroutines, which are like methods in Java.
他们遵循一种命令式的范式，将大型程序分解成称为子例程的小型程序，这与Java中的方法类似。

 Now back in the 1960s, computer processing time was costly.
现在回到20世纪60年代，计算机处理时间是昂贵的。

 As a result, it was important to maximize processing performance.
因此，最大化处理性能非常重要。

 This was accomplished by having global data because they are all located in one place in the computer's memory for a program.
这是通过拥有全局数据来实现的，因为它们都位于计算机内存中的一个位置上。

 With globally accessible variables, all the subroutines would be able to access them to do their necessary calculations.
有了全局可访问的变量，所有的子例程都可以访问它们来进行必要的计算。

 However, there are some problems that Ted noticed as he continued with his career.
然而，泰德在继续他的职业生涯时注意到了一些问题。

 With global data, it was possible that changes in the data could have weird side effects on the program.
对于全局数据，数据中的更改可能会对程序产生奇怪的副作用。

 Sometimes, a subroutine would run into cases where the global data was not as expected.
有时，一个子程序会遇到全局数据不符合预期的情况。

 The need for better data management led to changes to imperative programming and the rise of languages like Algol 68 and Pascal in the 1970s.
对更好的数据管理的需求导致了命令式编程的改变，以及像Algol 68和Pascal这样的语言在20世纪70年代的兴起。

 The idea of local variables was introduced.
引入了局部变量的概念。

 Subroutines were called procedures which could contain nested procedures.
子例程被称为可能包含嵌套过程的过程。

 And each one could have their own variables.
每个都有自己的变量。

 Algol 68 and Pascal support the notion of an abstract data type, which is a datatype that is defined by the programmer and not built into the language.
Algol 68和Pascal支持抽象数据类型的概念，抽象数据类型是由程序员定义的数据类型，而不是内置在语言中。

 An abstract data type is essentially a grouping of related information that is denoted with a type.
抽象数据类型本质上是用类型表示的相关信息的分组。

 It was a way to organize data in a meaningful way.
这是一种以有意义的方式组织数据的方法。

 Developers can write their software using these types in a similar way to the built-in types of the languages.
开发人员可以使用类似于语言内置类型的方式来使用这些类型编写软件。

 By having variables in different scopes, Ted can compartmentalize the data into different procedures.
通过将变量放在不同的作用域中，Ted可以将数据划分为不同的过程。

 This way, a procedure can be the only one that can modify that piece of data, allowing Ted to put it in the local scope and not have to worry about it being changed by another procedure.
通过这种方式，一个过程可以是唯一一个可以修改这段数据的过程，从而允许Ted将它放在本地范围内，而不必担心它会被另一个过程更改。

 As we continue on our journey into the mid-1970s, computer processing time became less expensive while human labor became more expensive.
随着我们继续进入20世纪70年代中期，计算机处理时间变得更便宜，而人力成本变得更贵。

 The time consuming factor in software development was now the human element.
软件开发中耗时的因素现在变成了人的因素。

 Problems were becoming more complex.
问题变得越来越复杂。

 The questions we could ask computers to solve were becoming more intricate.
我们可以让电脑解决的问题变得越来越复杂。

 For developers like Ted, this meant that software was becoming so massive that having one file for his program was becoming difficult to maintain.
对于像Ted这样的开发者来说，这意味着软件变得如此庞大，以至于为他的程序维护一个文件变得非常困难。

 New languages arose such as C and Modula-2 that provided a means to organize programs and allow developers to more easily create multiple but unique copies of their abstract data types.
新的语言如C和Modula-2出现了，它们提供了一种组织程序的方法，并允许开发人员更容易地创建其抽象数据类型的多个但唯一的副本。

 Programs could now be organized into separate files.
程序现在可以组织成单独的文件。

 In C, each file contained all the associated data and functions that manipulated it and it declared what could be accessed through a separate file called the Header File.
在C语言中，每个文件都包含了所有相关的数据和函数，这些数据和函数对文件进行操作，并声明可以通过一个名为头文件的单独文件访问哪些内容。

 There are still issues that are not addressed in any of the languages we've looked at so far.
到目前为止，仍然有一些问题没有在我们所研究的任何一种语言中得到解决。

 These languages do not make it easy for an abstract data type to inherit from another.
这些语言使抽象数据类型很难从其他类型继承。

 That means that Ted can define as many data types as he wants but cannot declare that one type is an extension of another type.
这意味着Ted可以定义任意多的数据类型，但不能声明一种类型是另一种类型的扩展。

 In the final leg of our journey, let's follow Ted into the 1980s.
在我们旅程的最后一段，让我们跟随Ted进入80年代。

 During this time in software history, the concepts of Object-Oriented Design, that are central for object-oriented programming, became popular.
在软件历史上的这段时间里，面向对象设计的概念(这是面向对象编程的核心)变得流行起来。

 The goal of object-oriented design is to make an abstract data type easier to write, structure a system around abstract data types called classes and introduce the ability for an abstract data type to extend another by introducing a concept called inheritance.
面向对象设计的目标是使抽象数据类型更容易编写，围绕称为类的抽象数据类型构造系统，并通过引入称为继承的概念引入抽象数据类型扩展其他类型的能力。

 With an object-oriented programming paradigm, Ted is now able to build a software system that is made up of entirely abstract data types.
通过一个面向对象的编程范例，Ted现在能够构建一个完全由抽象数据类型组成的软件系统。

 The advantage of this is that the system will mimic the structure of the problem, meaning that any object-oriented program is capable of representing real world objects or ideas with more fidelity.
这样做的好处是，系统将模拟问题的结构，这意味着任何面向对象的程序都能够更逼真地表示真实世界的对象或思想。

 Class files replace the standard files in C and Modula-2.
类文件替换了C和模块2中的标准文件。

 Each class defines a type with associated data and functions.
每个类都定义一个具有关联数据和函数的类型。

 These functions are also known as methods.
这些函数也称为方法。

 A class acts like a factory, making individual objects, all of a specific type.
类的作用类似于工厂，生成特定类型的单个对象。

 This allows Ted to compartmentalize the data and how it can be manipulated in their own separate classes.
这使得Ted可以划分数据，以及如何在它们自己的单独类中操作数据。

 Object-Oriented Programming is the predominant programming paradigm.
面向对象编程是主要的编程范式。

 Popular modern languages such as Java, C++ and C# are all founded based on objects.
流行的现代语言如Java、c++和c#都是基于对象的。

 So, why the big history lesson?
那么，为什么要上这么大的历史课呢?

 Why do we care about Ted and his journey through the different software design eras?
为什么我们关心Ted和他在不同软件设计时代的经历?

 It is important because as a software developer, you need to have a broad understanding of what is out there in the industry today.
这很重要，因为作为一名软件开发人员，您需要对当今的行业有一个广泛的了解。

 There are many systems that still use the older languages and design paradigms.
有许多系统仍然使用旧的语言和设计范例。

 It is also important to understand that while object-oriented programming is a powerful tool, it is not the only one in your toolbox.
虽然面向对象编程是一种强大的工具，但它并不是您的工具箱中惟一的工具，理解这一点也很重要。

 Object-oriented design is not always the best approach for everything because the design may not fit the problem.
面向对象的设计并不总是解决所有问题的最佳方法，因为设计可能不适合问题。

 Remember, that it is more important to be efficient with your time even if this means taking a non-object-oriented approach.
请记住，更重要的是有效利用时间，即使这意味着采用非面向对象的方法。

 As the power of computers becomes better than ever before, the most expensive cost of creating software is you.
随着计算机的能力变得比以往任何时候都强大，开发软件最昂贵的成本就是你自己。

